<!-- File: index.html -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>D&D Session Tracker</title>
  <style>
    :root { color-scheme: dark light; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 0; }
    .wrap { max-width: 1100px; margin: 0 auto; padding: 18px; }
    h1 { font-size: 20px; margin: 0 0 12px; }
    h2 { font-size: 16px; margin: 18px 0 10px; }
    .muted { opacity: .78; font-size: 12px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .pill { font-size: 12px; padding: 4px 8px; border-radius: 999px; border: 1px solid rgba(127,127,127,.35); opacity: .9; }
    .hidden { display: none; }

    .card { border: 1px solid rgba(127,127,127,.35); border-radius: 12px; padding: 14px; background: rgba(127,127,127,.06); }

    .topbar { display: flex; align-items: baseline; justify-content: space-between; gap: 12px; flex-wrap: wrap; }
    .btns { display: flex; flex-wrap: wrap; gap: 8px; }
    button {
      padding: 10px 12px; border-radius: 10px; border: 1px solid rgba(127,127,127,.35);
      background: rgba(127,127,127,.10); cursor: pointer; font-weight: 700;
    }
    button:hover { background: rgba(127,127,127,.18); }

    input[type="text"], input[type="number"], textarea, select {
      width: 100%; box-sizing: border-box; padding: 10px; border-radius: 10px;
      border: 1px solid rgba(127,127,127,.35); background: transparent; font-size: 14px;
    }
    textarea { min-height: 110px; resize: vertical; }

    .grid {
      display: grid;
      grid-template-columns: 1.1fr .9fr 1fr;
      gap: 12px;
      align-items: start;
    }
    @media (max-width: 980px) { .grid { grid-template-columns: 1fr; } }

    .panelTitle { display: flex; justify-content: space-between; align-items: baseline; gap: 10px; }
    .kv { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .kv3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; }
    .divider { height: 1px; background: rgba(127,127,127,.25); margin: 12px 0; }

    .hpRead { font-size: 28px; font-weight: 900; }
    .hpRead small { font-size: 14px; opacity: .8; font-weight: 800; }
    .hpControls { display: flex; flex-wrap: wrap; gap: 8px; justify-content: flex-end; }

    .mini {
      border: 1px dashed rgba(127,127,127,.35);
      border-radius: 12px;
      padding: 10px;
    }
    .mini h3 { margin: 0 0 8px; font-size: 13px; letter-spacing: .2px; }

    .list { display: grid; gap: 8px; }
    .row2 { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .row3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; }
    .row4 { display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 10px; }
    @media (max-width: 980px) { .row4 { grid-template-columns: 1fr 1fr; } }

    .checks { display: flex; flex-wrap: wrap; gap: 8px; }
    .checkPill {
      display: inline-flex; align-items: center; gap: 6px;
      border: 1px solid rgba(127,127,127,.35); border-radius: 999px;
      padding: 6px 10px; user-select: none;
    }

    table { width: 100%; border-collapse: collapse; }
    th, td { text-align: left; padding: 8px; border-bottom: 1px solid rgba(127,127,127,.25); }
    th { font-size: 12px; opacity: .85; }

    .slots { display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 10px; }
    .slotGroup { border: 1px dashed rgba(127,127,127,.35); border-radius: 12px; padding: 10px; }
    .slotTitle { display: flex; justify-content: space-between; align-items: baseline; gap: 8px; }
    .footer { margin-top: 14px; display: flex; justify-content: space-between; gap: 12px; flex-wrap: wrap; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <h1>D&D Session Tracker</h1>
      <div id="statusPill" class="pill">Setup</div>
    </div>

    <!-- SETUP -->
    <section id="setup" class="card hidden">
      <h2>Open a character</h2>
      <div class="kv">
        <div>
          <label for="setupKey">Character key (from link: ?pc=KEY)</label>
          <input id="setupKey" type="text" placeholder="e.g., seris" />
          <div class="muted">If the character has no saved session yet, it will seed from presets (if present).</div>
        </div>
        <div>
          <label for="setupName">Or enter name (local save key)</label>
          <input id="setupName" type="text" placeholder="e.g., Seris Dawnblade" />
          <div class="muted">Name-based load is fallback if you don’t use presets.</div>
        </div>
      </div>

      <div class="btns" style="margin-top:10px;">
        <button id="btnOpen">Open</button>
      </div>

      <div class="divider"></div>
      <div class="muted">
        Preset keys available on this page:
        <span class="mono" id="presetKeys">—</span>
      </div>
    </section>

    <!-- APP -->
    <section id="app" class="card hidden">
      <div class="topbar">
        <div>
          <div style="font-size:18px;font-weight:900;">
            <span id="charName">—</span>
            <span class="muted">· Level <span id="charLevel">—</span> <span id="charClassRace"></span></span>
          </div>
          <div class="muted">
            Save key: <span class="mono" id="saveKey">—</span> · Last saved: <span id="lastSaved">—</span>
          </div>
        </div>
        <div class="btns">
          <button id="btnLongRest">Long Rest</button>
          <button id="btnSwitch">Switch</button>
          <button id="btnReset">Reset Character</button>
          <button id="btnExport">Export JSON</button>
          <button id="btnImport">Import JSON</button>
          <input id="fileImport" type="file" accept="application/json" class="hidden" />
        </div>
      </div>

      <div class="grid" style="margin-top:12px;">
        <!-- LEFT COLUMN -->
        <div class="list">
          <div class="mini">
            <div class="panelTitle">
              <h3>Vitals</h3>
              <span class="muted">Editable</span>
            </div>

            <div class="row2">
              <div>
                <label for="inputClass">Class</label>
                <input id="inputClass" type="text" />
              </div>
              <div>
                <label for="inputRace">Race</label>
                <input id="inputRace" type="text" />
              </div>
            </div>

            <div class="row4" style="margin-top:10px;">
              <div>
                <label for="inputLevel">Level</label>
                <input id="inputLevel" type="number" min="1" max="20" />
              </div>
              <div>
                <label for="inputProf">Prof Bonus</label>
                <input id="inputProf" type="number" />
              </div>
              <div>
                <label for="inputAc">AC</label>
                <input id="inputAc" type="number" min="0" />
              </div>
              <div>
                <label for="inputSpeed">Speed (ft)</label>
                <input id="inputSpeed" type="number" min="0" />
              </div>
            </div>

            <div class="row3" style="margin-top:10px;">
              <div>
                <label for="inputInit">Initiative</label>
                <input id="inputInit" type="number" />
              </div>
              <div>
                <label for="inputMaxHp">Max HP</label>
                <input id="inputMaxHp" type="number" min="1" />
              </div>
              <div>
                <label for="inputCurrentHp">Current HP</label>
                <input id="inputCurrentHp" type="number" min="0" />
              </div>
            </div>

            <div class="row2" style="margin-top:10px; align-items:end;">
              <div class="hpRead">
                <span id="hpCurrent">0</span> <small>/ <span id="hpMax">0</span></small>
              </div>
              <div class="hpControls">
                <button data-hp="-5">-5</button>
                <button data-hp="-1">-1</button>
                <button data-hp="+1">+1</button>
                <button data-hp="+5">+5</button>
              </div>
            </div>
          </div>

          <div class="mini">
            <div class="panelTitle">
              <h3>Ability Scores</h3>
              <span class="muted">Mods auto-calc</span>
            </div>
            <div class="row3">
              <div><label for="abStr">STR</label><input id="abStr" type="number" min="1" max="30" /></div>
              <div><label for="abDex">DEX</label><input id="abDex" type="number" min="1" max="30" /></div>
              <div><label for="abCon">CON</label><input id="abCon" type="number" min="1" max="30" /></div>
              <div><label for="abInt">INT</label><input id="abInt" type="number" min="1" max="30" /></div>
              <div><label for="abWis">WIS</label><input id="abWis" type="number" min="1" max="30" /></div>
              <div><label for="abCha">CHA</label><input id="abCha" type="number" min="1" max="30" /></div>
            </div>
            <div class="divider"></div>
            <div class="row3">
              <div class="muted">STR mod: <span class="mono" id="modStr">+0</span></div>
              <div class="muted">DEX mod: <span class="mono" id="modDex">+0</span></div>
              <div class="muted">CON mod: <span class="mono" id="modCon">+0</span></div>
              <div class="muted">INT mod: <span class="mono" id="modInt">+0</span></div>
              <div class="muted">WIS mod: <span class="mono" id="modWis">+0</span></div>
              <div class="muted">CHA mod: <span class="mono" id="modCha">+0</span></div>
            </div>
          </div>

          <div class="mini">
            <div class="panelTitle">
              <h3>Saves & Skills</h3>
              <span class="muted">Toggle prof/expertise</span>
            </div>

            <h2 style="margin:10px 0 6px;">Saving Throws</h2>
            <table id="savesTable"></table>

            <h2 style="margin:14px 0 6px;">Skills</h2>
            <table id="skillsTable"></table>
          </div>
        </div>

        <!-- MIDDLE COLUMN -->
        <div class="list">
          <div class="mini">
            <div class="panelTitle">
              <h3>Attacks</h3>
              <button id="btnAddAttack" title="Add a new attack">Add</button>
            </div>
            <div id="attacksList" class="list"></div>
          </div>

          <div class="mini">
            <div class="panelTitle">
              <h3>Features / Feats</h3>
              <span class="muted">Text</span>
            </div>
            <label for="features">Class features, feats, traits</label>
            <textarea id="features" placeholder="Second Wind, Action Surge, Fighting Style, etc."></textarea>
          </div>

          <div class="mini">
            <div class="panelTitle">
              <h3>Spell Slots</h3>
              <span class="muted">Optional</span>
            </div>
            <div class="row3">
              <div>
                <label for="spellAbility">Spellcasting ability</label>
                <select id="spellAbility">
                  <option value="">—</option>
                  <option value="int">INT</option>
                  <option value="wis">WIS</option>
                  <option value="cha">CHA</option>
                </select>
              </div>
              <div>
                <label for="spellDc">Spell Save DC</label>
                <input id="spellDc" type="number" min="0" />
              </div>
              <div>
                <label for="spellAtk">Spell Attack</label>
                <input id="spellAtk" type="number" />
              </div>
            </div>

            <div class="divider"></div>
            <div id="slots" class="slots"></div>

            <div class="divider"></div>
            <div class="muted">Configure slot maximums (0–9):</div>
            <div id="slotMaxEditors" class="row3" style="margin-top:8px;"></div>
          </div>
        </div>

        <!-- RIGHT COLUMN -->
        <div class="list">
          <div class="mini">
            <div class="panelTitle">
              <h3>About</h3>
              <span class="muted">Public</span>
            </div>
            <label for="about">Short description</label>
            <textarea id="about"></textarea>
          </div>

          <div class="mini">
            <div class="panelTitle">
              <h3>Rumor</h3>
              <span class="muted">Private</span>
            </div>
            <label for="rumor">Only this player should see</label>
            <textarea id="rumor"></textarea>
          </div>

          <div class="mini">
            <div class="panelTitle">
              <h3>Backpack</h3>
              <span class="muted">Inventory</span>
            </div>
            <label for="inventory">Items (one per line)</label>
            <textarea id="inventory" placeholder="- Potion of Healing&#10;- Rope (50 ft)"></textarea>
          </div>

          <div class="mini">
            <div class="panelTitle">
              <h3>Session Notes</h3>
              <span class="muted">Free-form</span>
            </div>
            <label for="notes">Notes</label>
            <textarea id="notes" placeholder="NPC names, clues, reminders..."></textarea>
          </div>
        </div>
      </div>
    </section>
  </div>

  <script>
    /**
     * ✅ EDIT HERE: prefill your PCs
     * Key is what you put in the URL: ?pc=<key>
     */
    const PRESETS = {
      seris: {
        name: "Seris Dawnblade",
        className: "Fighter",
        race: "Human",
        level: 2,
        profBonus: 2,
        ac: 16,
        initiative: 1,
        speed: 30,
        maxHp: 20,
        abilities: { str: 16, dex: 12, con: 14, int: 10, wis: 12, cha: 12 },
        saves: { str: "prof", con: "prof" }, // "none" | "prof"
        skills: {
          athletics: "prof",
          perception: "prof",
          intimidation: "prof",
          // set others to "none" or omit
        },
        attacks: [
          { name: "Longsword (Melee)", toHit: 5, damage: "1d8+5", notes: "" },
        ],
        features: "Second Wind (1/Short Rest)\nFighting Style: Dueling\nAction Surge (1/Short Rest)",
        about: "A disciplined sword-for-hire escorting a small merchant group to and from the Crystal Faire.",
        rumor: "You once failed to hold a line. A village burned because you were ordered to retreat...",
        spell: {
          ability: "",
          dc: 0,
          attack: 0,
          slotMaxByLevel: { 1:0,2:0,3:0,4:0,5:0,6:0,7:0,8:0,9:0 },
        },
      },
    };

    const STORAGE_PREFIX = "dnd-tracker:";
    const $ = (id) => document.getElementById(id);

    const ui = {
      setup: $("setup"),
      app: $("app"),
      statusPill: $("statusPill"),
      presetKeys: $("presetKeys"),

      setupKey: $("setupKey"),
      setupName: $("setupName"),
      btnOpen: $("btnOpen"),

      charName: $("charName"),
      charLevel: $("charLevel"),
      charClassRace: $("charClassRace"),
      saveKey: $("saveKey"),
      lastSaved: $("lastSaved"),

      inputClass: $("inputClass"),
      inputRace: $("inputRace"),
      inputLevel: $("inputLevel"),
      inputProf: $("inputProf"),
      inputAc: $("inputAc"),
      inputSpeed: $("inputSpeed"),
      inputInit: $("inputInit"),
      inputMaxHp: $("inputMaxHp"),
      inputCurrentHp: $("inputCurrentHp"),
      hpCurrent: $("hpCurrent"),
      hpMax: $("hpMax"),

      abStr: $("abStr"), abDex: $("abDex"), abCon: $("abCon"),
      abInt: $("abInt"), abWis: $("abWis"), abCha: $("abCha"),
      modStr: $("modStr"), modDex: $("modDex"), modCon: $("modCon"),
      modInt: $("modInt"), modWis: $("modWis"), modCha: $("modCha"),

      savesTable: $("savesTable"),
      skillsTable: $("skillsTable"),

      attacksList: $("attacksList"),
      btnAddAttack: $("btnAddAttack"),

      features: $("features"),

      spellAbility: $("spellAbility"),
      spellDc: $("spellDc"),
      spellAtk: $("spellAtk"),
      slots: $("slots"),
      slotMaxEditors: $("slotMaxEditors"),

      about: $("about"),
      rumor: $("rumor"),
      inventory: $("inventory"),
      notes: $("notes"),

      btnLongRest: $("btnLongRest"),
      btnSwitch: $("btnSwitch"),
      btnReset: $("btnReset"),
      btnExport: $("btnExport"),
      btnImport: $("btnImport"),
      fileImport: $("fileImport"),
    };

    /** @type {any|null} */
    let state = null;

    const ABILS = /** @type {const} */ (["str","dex","con","int","wis","cha"]);
    const SAVE_LABEL = { str:"STR", dex:"DEX", con:"CON", int:"INT", wis:"WIS", cha:"CHA" };

    const SKILLS = [
      { key:"acrobatics", label:"Acrobatics", abil:"dex" },
      { key:"animal_handling", label:"Animal Handling", abil:"wis" },
      { key:"arcana", label:"Arcana", abil:"int" },
      { key:"athletics", label:"Athletics", abil:"str" },
      { key:"deception", label:"Deception", abil:"cha" },
      { key:"history", label:"History", abil:"int" },
      { key:"insight", label:"Insight", abil:"wis" },
      { key:"intimidation", label:"Intimidation", abil:"cha" },
      { key:"investigation", label:"Investigation", abil:"int" },
      { key:"medicine", label:"Medicine", abil:"wis" },
      { key:"nature", label:"Nature", abil:"int" },
      { key:"perception", label:"Perception", abil:"wis" },
      { key:"performance", label:"Performance", abil:"cha" },
      { key:"persuasion", label:"Persuasion", abil:"cha" },
      { key:"religion", label:"Religion", abil:"int" },
      { key:"sleight_of_hand", label:"Sleight of Hand", abil:"dex" },
      { key:"stealth", label:"Stealth", abil:"dex" },
      { key:"survival", label:"Survival", abil:"wis" },
    ];

    function saveKeyForName(name) {
      return `${STORAGE_PREFIX}${String(name).trim().toLowerCase()}`;
    }

    function nowIso() { return new Date().toISOString(); }
    function formatLocalTime(iso) { try { return new Date(iso).toLocaleString(); } catch { return "—"; } }
    function clampInt(n, min, max) {
      const x = Number.isFinite(n) ? Math.trunc(n) : min;
      return Math.max(min, Math.min(max, x));
    }
    function modFromScore(score) { return Math.floor((score - 10) / 2); }
    function fmtSigned(n) { return (n >= 0 ? "+" : "") + String(n); }

    function debounce(fn, ms) {
      let t = null;
      return (...args) => {
        if (t) clearTimeout(t);
        t = setTimeout(() => fn(...args), ms);
      };
    }

    function setView(view) {
      ui.setup.classList.toggle("hidden", view !== "setup");
      ui.app.classList.toggle("hidden", view !== "app");
    }

    function parsePcKeyFromUrl() {
      const u = new URL(window.location.href);
      return (u.searchParams.get("pc") || "").trim();
    }

    function setUrlPcKey(pcKey) {
      const u = new URL(window.location.href);
      if (pcKey) u.searchParams.set("pc", pcKey);
      history.replaceState(null, "", u.toString());
    }

    function buildStateFromPreset(pcKey, preset) {
      const slotMaxByLevel = preset?.spell?.slotMaxByLevel || {};
      const spellSlots = {};
      for (let lvl = 1; lvl <= 9; lvl++) {
        const max = clampInt(Number(slotMaxByLevel[lvl] ?? 0), 0, 99);
        spellSlots[String(lvl)] = { max, used: Array.from({ length: max }, () => false) };
      }

      const abilities = preset.abilities || { str:10,dex:10,con:10,int:10,wis:10,cha:10 };

      return {
        version: 2,
        pcKey: pcKey || "",
        name: preset.name || "",
        className: preset.className || "",
        race: preset.race || "",
        level: clampInt(Number(preset.level ?? 1), 1, 20),
        profBonus: clampInt(Number(preset.profBonus ?? 2), -10, 20),

        ac: clampInt(Number(preset.ac ?? 10), 0, 99),
        initiative: clampInt(Number(preset.initiative ?? 0), -30, 30),
        speed: clampInt(Number(preset.speed ?? 30), 0, 999),

        maxHp: clampInt(Number(preset.maxHp ?? 1), 1, 9999),
        currentHp: clampInt(Number(preset.maxHp ?? 1), 0, 9999),

        abilities: {
          str: clampInt(Number(abilities.str ?? 10), 1, 30),
          dex: clampInt(Number(abilities.dex ?? 10), 1, 30),
          con: clampInt(Number(abilities.con ?? 10), 1, 30),
          int: clampInt(Number(abilities.int ?? 10), 1, 30),
          wis: clampInt(Number(abilities.wis ?? 10), 1, 30),
          cha: clampInt(Number(abilities.cha ?? 10), 1, 30),
        },

        saves: preset.saves || {},          // { str: "prof" }
        skills: preset.skills || {},        // { athletics: "prof" | "expert" }

        attacks: Array.isArray(preset.attacks) ? preset.attacks : [],
        features: preset.features || "",

        about: preset.about || "",
        rumor: preset.rumor || "",

        spell: {
          ability: preset?.spell?.ability || "",
          dc: clampInt(Number(preset?.spell?.dc ?? 0), 0, 50),
          attack: clampInt(Number(preset?.spell?.attack ?? 0), -50, 50),
          spellSlots,
        },

        inventory: "",
        notes: "",
        updatedAt: nowIso(),
      };
    }

    function migrateAndNormalize(s) {
      // Accept older shapes; normalize into version 2
      const v = Number(s?.version ?? 1);
      if (v === 2) {
        const out = structuredClone(s);
        out.name = String(out.name ?? "").trim();
        out.level = clampInt(Number(out.level ?? 1), 1, 20);
        out.profBonus = clampInt(Number(out.profBonus ?? 2), -10, 20);
        out.maxHp = clampInt(Number(out.maxHp ?? 1), 1, 9999);
        out.currentHp = clampInt(Number(out.currentHp ?? out.maxHp), 0, out.maxHp);
        out.ac = clampInt(Number(out.ac ?? 10), 0, 99);
        out.initiative = clampInt(Number(out.initiative ?? 0), -30, 30);
        out.speed = clampInt(Number(out.speed ?? 30), 0, 999);

        out.abilities = out.abilities || {};
        for (const a of ABILS) out.abilities[a] = clampInt(Number(out.abilities[a] ?? 10), 1, 30);

        out.saves = out.saves || {};
        out.skills = out.skills || {};
        out.attacks = Array.isArray(out.attacks) ? out.attacks : [];
        out.spell = out.spell || { ability:"", dc:0, attack:0, spellSlots:{} };
        out.spell.spellSlots = out.spell.spellSlots || {};

        for (let lvl = 1; lvl <= 9; lvl++) {
          const k = String(lvl);
          const group = out.spell.spellSlots[k] || { max: 0, used: [] };
          const max = clampInt(Number(group.max ?? 0), 0, 99);
          const usedArr = Array.isArray(group.used) ? group.used.map(Boolean) : [];
          out.spell.spellSlots[k] = { max, used: Array.from({ length: max }, (_, i) => Boolean(usedArr[i] ?? false)) };
        }

        out.inventory = String(out.inventory ?? "");
        out.notes = String(out.notes ?? "");
        out.updatedAt = String(out.updatedAt ?? nowIso());
        return out;
      }

      // v1 → v2 best-effort
      const pcKey = String(s?.pcKey ?? "");
      const preset = pcKey && PRESETS[pcKey] ? PRESETS[pcKey] : null;
      const base = preset ? buildStateFromPreset(pcKey, preset) : buildStateFromPreset("", { name: String(s?.name ?? "Unknown") });

      base.maxHp = clampInt(Number(s?.maxHp ?? base.maxHp), 1, 9999);
      base.currentHp = clampInt(Number(s?.currentHp ?? base.maxHp), 0, base.maxHp);
      base.inventory = String(s?.inventory ?? "");
      base.notes = String(s?.notes ?? "");
      base.updatedAt = String(s?.updatedAt ?? nowIso());
      return base;
    }

    function loadStateByName(name) {
      const key = saveKeyForName(name);
      const raw = localStorage.getItem(key);
      if (!raw) return null;
      try { return migrateAndNormalize(JSON.parse(raw)); } catch { return null; }
    }

    function persistState() {
      if (!state) return;
      const key = saveKeyForName(state.name);
      state.updatedAt = nowIso();
      localStorage.setItem(key, JSON.stringify(state));
      ui.lastSaved.textContent = formatLocalTime(state.updatedAt);
      ui.saveKey.textContent = key;
      ui.statusPill.textContent = "Saved";
    }
    const persistStateDebounced = debounce(persistState, 250);

    function recalcAndRenderDerived() {
      if (!state) return;
      const mods = {};
      for (const a of ABILS) mods[a] = modFromScore(state.abilities[a]);

      ui.modStr.textContent = fmtSigned(mods.str);
      ui.modDex.textContent = fmtSigned(mods.dex);
      ui.modCon.textContent = fmtSigned(mods.con);
      ui.modInt.textContent = fmtSigned(mods.int);
      ui.modWis.textContent = fmtSigned(mods.wis);
      ui.modCha.textContent = fmtSigned(mods.cha);

      renderSaves(mods);
      renderSkills(mods);
    }

    function profValue(kind) {
      // "none" | "prof" | "expert"
      if (kind === "expert") return 2;
      if (kind === "prof") return 1;
      return 0;
    }

    function renderSaves(mods) {
      const pb = Number(state.profBonus) || 0;
      ui.savesTable.innerHTML = `
        <tr><th>Save</th><th>Prof?</th><th>Total</th></tr>
        ${ABILS.map((a) => {
          const kind = state.saves[a] || "none";
          const total = mods[a] + pb * profValue(kind);
          return `
            <tr>
              <td>${SAVE_LABEL[a]}</td>
              <td>
                <label class="checkPill">
                  <input type="checkbox" data-save-prof="${a}" ${kind === "prof" ? "checked" : ""}>
                  Proficient
                </label>
              </td>
              <td class="mono">${fmtSigned(total)}</td>
            </tr>
          `;
        }).join("")}
      `;
    }

    function renderSkills(mods) {
      const pb = Number(state.profBonus) || 0;
      ui.skillsTable.innerHTML = `
        <tr><th>Skill</th><th>Ability</th><th>Prof</th><th>Expert</th><th>Total</th></tr>
        ${SKILLS.map((s) => {
          const kind = state.skills[s.key] || "none";
          const total = mods[s.abil] + pb * profValue(kind);
          return `
            <tr>
              <td>${s.label}</td>
              <td class="mono">${s.abil.toUpperCase()}</td>
              <td>
                <input type="radio" name="skill_${s.key}" data-skill="${s.key}" value="prof" ${kind === "prof" ? "checked" : ""}>
              </td>
              <td>
                <input type="radio" name="skill_${s.key}" data-skill="${s.key}" value="expert" ${kind === "expert" ? "checked" : ""}>
              </td>
              <td class="mono">${fmtSigned(total)}</td>
            </tr>
          `;
        }).join("")}
      `;

      // add a "none" option implicitly by clicking already-checked radio? not possible → add clear button row:
      // keep UI simple: allow clearing via context menu is annoying; add a separate toggle handler below using alt-click.
      ui.skillsTable.querySelectorAll('input[type="radio"][data-skill]').forEach((r) => {
        r.addEventListener("click", (e) => {
          if (!state) return;
          const el = /** @type {HTMLInputElement} */ (e.currentTarget);
          const key = el.getAttribute("data-skill");
          const val = el.value;
          if (!key) return;

          // alt-click to clear to none (quick)
          if (e.altKey) {
            delete state.skills[key];
            recalcAndRenderDerived();
            ui.statusPill.textContent = "Unsaved";
            persistStateDebounced();
            return;
          }

          state.skills[key] = val;
          recalcAndRenderDerived();
          ui.statusPill.textContent = "Unsaved";
          persistStateDebounced();
        });
      });
    }

    function renderAttacks() {
      ui.attacksList.innerHTML = "";
      const list = Array.isArray(state.attacks) ? state.attacks : [];
      if (!list.length) {
        const div = document.createElement("div");
        div.className = "muted";
        div.textContent = "No attacks yet. Click Add.";
        ui.attacksList.appendChild(div);
        return;
      }

      list.forEach((atk, idx) => {
        const box = document.createElement("div");
        box.className = "mini";
        box.innerHTML = `
          <div class="panelTitle">
            <h3>Attack ${idx + 1}</h3>
            <button data-del-attack="${idx}" title="Delete this attack">Delete</button>
          </div>
          <div class="row2">
            <div>
              <label>Name</label>
              <input type="text" data-atk="${idx}" data-field="name" value="${escapeHtml(atk.name || "")}">
            </div>
            <div class="row2">
              <div>
                <label>To Hit</label>
                <input type="number" data-atk="${idx}" data-field="toHit" value="${Number(atk.toHit ?? 0)}">
              </div>
              <div>
                <label>Damage</label>
                <input type="text" data-atk="${idx}" data-field="damage" value="${escapeHtml(atk.damage || "")}">
              </div>
            </div>
          </div>
          <div style="margin-top:10px;">
            <label>Notes</label>
            <input type="text" data-atk="${idx}" data-field="notes" value="${escapeHtml(atk.notes || "")}">
          </div>
        `;
        ui.attacksList.appendChild(box);
      });

      ui.attacksList.querySelectorAll("button[data-del-attack]").forEach((b) => {
        b.addEventListener("click", (e) => {
          const idx = Number(e.currentTarget.getAttribute("data-del-attack"));
          state.attacks.splice(idx, 1);
          renderAttacks();
          ui.statusPill.textContent = "Unsaved";
          persistStateDebounced();
        });
      });

      ui.attacksList.querySelectorAll("input[data-atk]").forEach((inp) => {
        inp.addEventListener("input", (e) => {
          const el = /** @type {HTMLInputElement} */ (e.currentTarget);
          const idx = Number(el.getAttribute("data-atk"));
          const field = el.getAttribute("data-field");
          if (!Number.isFinite(idx) || !field) return;
          const atk = state.attacks[idx];
          if (!atk) return;

          atk[field] = field === "toHit" ? clampInt(Number(el.value), -50, 50) : el.value;
          ui.statusPill.textContent = "Unsaved";
          persistStateDebounced();
        });
      });
    }

    function escapeHtml(s) {
      return String(s)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    }

    function renderSlots() {
      ui.slots.innerHTML = "";
      for (let lvl = 1; lvl <= 9; lvl++) {
        const k = String(lvl);
        const group = state.spell.spellSlots[k];
        if (!group || group.max <= 0) continue;

        const box = document.createElement("div");
        box.className = "slotGroup";
        box.innerHTML = `
          <div class="slotTitle">
            <div><strong>Level ${lvl}</strong> <span class="muted">(${group.used.filter(Boolean).length}/${group.max} used)</span></div>
            <button data-slot-reset="${k}">Clear</button>
          </div>
          <div class="checks" style="margin-top:8px;">
            ${group.used.map((used, idx) => `
              <label class="checkPill">
                <input type="checkbox" data-slot="${k}" data-slot-idx="${idx}" ${used ? "checked" : ""}/>
                Slot ${idx + 1}
              </label>
            `).join("")}
          </div>
        `;
        ui.slots.appendChild(box);
      }

      if (!ui.slots.children.length) {
        const empty = document.createElement("div");
        empty.className = "muted";
        empty.textContent = "No spell slots configured.";
        ui.slots.appendChild(empty);
      }

      ui.slots.querySelectorAll('input[type="checkbox"][data-slot]').forEach((c) => {
        c.addEventListener("change", (e) => {
          const el = /** @type {HTMLInputElement} */ (e.currentTarget);
          const lvl = el.getAttribute("data-slot");
          const idx = Number(el.getAttribute("data-slot-idx"));
          if (!lvl || !Number.isFinite(idx)) return;
          state.spell.spellSlots[lvl].used[idx] = el.checked;
          renderSlots();
          ui.statusPill.textContent = "Unsaved";
          persistStateDebounced();
        });
      });

      ui.slots.querySelectorAll("button[data-slot-reset]").forEach((b) => {
        b.addEventListener("click", (e) => {
          const lvl = e.currentTarget.getAttribute("data-slot-reset");
          if (!lvl) return;
          state.spell.spellSlots[lvl].used = state.spell.spellSlots[lvl].used.map(() => false);
          renderSlots();
          ui.statusPill.textContent = "Unsaved";
          persistStateDebounced();
        });
      });
    }

    function renderSlotMaxEditors() {
      ui.slotMaxEditors.innerHTML = "";
      for (let lvl = 1; lvl <= 9; lvl++) {
        const k = String(lvl);
        const wrap = document.createElement("div");
        wrap.innerHTML = `
          <label for="slotMax_${k}">Lvl ${k}</label>
          <input id="slotMax_${k}" type="number" min="0" max="99" value="${Number(state.spell.spellSlots[k].max)}" />
        `;
        ui.slotMaxEditors.appendChild(wrap);

        wrap.querySelector("input").addEventListener("input", (e) => {
          const max = clampInt(Number(e.currentTarget.value), 0, 99);
          const used = state.spell.spellSlots[k].used || [];
          state.spell.spellSlots[k].max = max;
          state.spell.spellSlots[k].used = Array.from({ length: max }, (_, i) => Boolean(used[i] ?? false));
          renderSlots();
          ui.statusPill.textContent = "Unsaved";
          persistStateDebounced();
        });
      }
    }

    function renderApp() {
      ui.charName.textContent = state.name;
      ui.charLevel.textContent = String(state.level);
      ui.charClassRace.textContent = `· ${state.className || ""}${state.race ? " (" + state.race + ")" : ""}`;

      ui.inputClass.value = state.className || "";
      ui.inputRace.value = state.race || "";
      ui.inputLevel.value = String(state.level);
      ui.inputProf.value = String(state.profBonus);
      ui.inputAc.value = String(state.ac);
      ui.inputSpeed.value = String(state.speed);
      ui.inputInit.value = String(state.initiative);

      ui.inputMaxHp.value = String(state.maxHp);
      ui.inputCurrentHp.value = String(state.currentHp);
      ui.hpMax.textContent = String(state.maxHp);
      ui.hpCurrent.textContent = String(state.currentHp);

      ui.abStr.value = String(state.abilities.str);
      ui.abDex.value = String(state.abilities.dex);
      ui.abCon.value = String(state.abilities.con);
      ui.abInt.value = String(state.abilities.int);
      ui.abWis.value = String(state.abilities.wis);
      ui.abCha.value = String(state.abilities.cha);

      ui.features.value = state.features || "";
      ui.about.value = state.about || "";
      ui.rumor.value = state.rumor || "";
      ui.inventory.value = state.inventory || "";
      ui.notes.value = state.notes || "";

      ui.spellAbility.value = state.spell.ability || "";
      ui.spellDc.value = String(state.spell.dc || 0);
      ui.spellAtk.value = String(state.spell.attack || 0);

      ui.lastSaved.textContent = formatLocalTime(state.updatedAt);
      ui.saveKey.textContent = saveKeyForName(state.name);

      renderAttacks();
      renderSlots();
      renderSlotMaxEditors();
      recalcAndRenderDerived();
      ui.statusPill.textContent = "Loaded";
    }

    function applyHpDelta(delta) {
      state.currentHp = clampInt(state.currentHp + delta, 0, state.maxHp);
      ui.inputCurrentHp.value = String(state.currentHp);
      ui.hpCurrent.textContent = String(state.currentHp);
      ui.statusPill.textContent = "Unsaved";
      persistStateDebounced();
    }

    function attachHandlers() {
      document.querySelectorAll("button[data-hp]").forEach((btn) => {
        btn.addEventListener("click", () => applyHpDelta(Number(btn.getAttribute("data-hp"))));
      });

      function bindInput(el, setter) {
        el.addEventListener("input", () => {
          setter();
          ui.statusPill.textContent = "Unsaved";
          persistStateDebounced();
        });
      }

      bindInput(ui.inputClass, () => { state.className = ui.inputClass.value; ui.charClassRace.textContent = `· ${state.className || ""}${state.race ? " (" + state.race + ")" : ""}`; });
      bindInput(ui.inputRace, () => { state.race = ui.inputRace.value; ui.charClassRace.textContent = `· ${state.className || ""}${state.race ? " (" + state.race + ")" : ""}`; });
      bindInput(ui.inputLevel, () => { state.level = clampInt(Number(ui.inputLevel.value), 1, 20); ui.charLevel.textContent = String(state.level); });
      bindInput(ui.inputProf, () => { state.profBonus = clampInt(Number(ui.inputProf.value), -10, 20); recalcAndRenderDerived(); });
      bindInput(ui.inputAc, () => { state.ac = clampInt(Number(ui.inputAc.value), 0, 99); });
      bindInput(ui.inputSpeed, () => { state.speed = clampInt(Number(ui.inputSpeed.value), 0, 999); });
      bindInput(ui.inputInit, () => { state.initiative = clampInt(Number(ui.inputInit.value), -30, 30); });

      bindInput(ui.inputMaxHp, () => {
        state.maxHp = clampInt(Number(ui.inputMaxHp.value), 1, 9999);
        state.currentHp = clampInt(state.currentHp, 0, state.maxHp);
        ui.hpMax.textContent = String(state.maxHp);
        ui.inputCurrentHp.value = String(state.currentHp);
        ui.hpCurrent.textContent = String(state.currentHp);
      });

      bindInput(ui.inputCurrentHp, () => {
        state.currentHp = clampInt(Number(ui.inputCurrentHp.value), 0, state.maxHp);
        ui.hpCurrent.textContent = String(state.currentHp);
      });

      const abilBindings = [
        [ui.abStr, "str"], [ui.abDex, "dex"], [ui.abCon, "con"],
        [ui.abInt, "int"], [ui.abWis, "wis"], [ui.abCha, "cha"],
      ];
      abilBindings.forEach(([el, key]) => bindInput(el, () => {
        state.abilities[key] = clampInt(Number(el.value), 1, 30);
        recalcAndRenderDerived();
      }));

      ui.savesTable.addEventListener("change", (e) => {
        const t = e.target;
        if (!(t instanceof HTMLInputElement)) return;
        const a = t.getAttribute("data-save-prof");
        if (!a) return;
        state.saves[a] = t.checked ? "prof" : "none";
        recalcAndRenderDerived();
        ui.statusPill.textContent = "Unsaved";
        persistStateDebounced();
      });

      bindInput(ui.features, () => { state.features = ui.features.value; });
      bindInput(ui.about, () => { state.about = ui.about.value; });
      bindInput(ui.rumor, () => { state.rumor = ui.rumor.value; });
      bindInput(ui.inventory, () => { state.inventory = ui.inventory.value; });
      bindInput(ui.notes, () => { state.notes = ui.notes.value; });

      bindInput(ui.spellAbility, () => { state.spell.ability = ui.spellAbility.value; });
      bindInput(ui.spellDc, () => { state.spell.dc = clampInt(Number(ui.spellDc.value), 0, 50); });
      bindInput(ui.spellAtk, () => { state.spell.attack = clampInt(Number(ui.spellAtk.value), -50, 50); });

      ui.btnAddAttack.addEventListener("click", () => {
        state.attacks.push({ name: "New Attack", toHit: 0, damage: "", notes: "" });
        renderAttacks();
        ui.statusPill.textContent = "Unsaved";
        persistStateDebounced();
      });

      ui.btnLongRest.addEventListener("click", () => {
        state.currentHp = state.maxHp;
        for (let lvl = 1; lvl <= 9; lvl++) {
          const k = String(lvl);
          state.spell.spellSlots[k].used = state.spell.spellSlots[k].used.map(() => false);
        }
        renderApp();
        ui.statusPill.textContent = "Unsaved";
        persistStateDebounced();
      });

      ui.btnSwitch.addEventListener("click", () => {
        state = null;
        ui.statusPill.textContent = "Setup";
        setView("setup");
      });

      ui.btnReset.addEventListener("click", () => {
        if (!state) return;
        localStorage.removeItem(saveKeyForName(state.name));
        state = null;
        ui.statusPill.textContent = "Deleted";
        setView("setup");
      });

      ui.btnExport.addEventListener("click", () => {
        const blob = new Blob([JSON.stringify(state, null, 2)], { type: "application/json" });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = `${state.name.replace(/\s+/g, "_")}_save.json`;
        a.click();
        URL.revokeObjectURL(a.href);
      });

      ui.btnImport.addEventListener("click", () => ui.fileImport.click());
      ui.fileImport.addEventListener("change", async () => {
        const file = ui.fileImport.files?.[0];
        ui.fileImport.value = "";
        if (!file) return;
        try {
          const text = await file.text();
          state = migrateAndNormalize(JSON.parse(text));
          persistState();
          setView("app");
          renderApp();
        } catch (err) {
          alert("Import failed: " + (err?.message || String(err)));
        }
      });

      ui.btnOpen.addEventListener("click", () => openFromSetup());
    }

    function openFromSetup() {
      const pcKey = ui.setupKey.value.trim();
      const name = ui.setupName.value.trim();

      // Priority: pcKey preset → saved by that preset name → else seed preset
      if (pcKey) {
        const preset = PRESETS[pcKey];
        if (!preset) {
          alert(`Unknown preset key: ${pcKey}`);
          return;
        }

        const existing = loadStateByName(preset.name);
        state = existing || buildStateFromPreset(pcKey, preset);
        setUrlPcKey(pcKey);
        persistState();
        setView("app");
        renderApp();
        return;
      }

      // Fallback: name-only
      if (!name) {
        alert("Enter a preset key (?pc=...) or a name.");
        return;
      }

      const existing = loadStateByName(name);
      state = existing || buildStateFromPreset("", { name });
      persistState();
      setView("app");
      renderApp();
    }

    function boot() {
      ui.presetKeys.textContent = Object.keys(PRESETS).length ? Object.keys(PRESETS).join(", ") : "—";
      attachHandlers();

      const urlPc = parsePcKeyFromUrl();
      if (urlPc && PRESETS[urlPc]) {
        ui.setupKey.value = urlPc;
        const preset = PRESETS[urlPc];
        const existing = loadStateByName(preset.name);
        state = existing || buildStateFromPreset(urlPc, preset);
        persistState();
        setView("app");
        renderApp();
        ui.statusPill.textContent = "Loaded from link";
        return;
      }

      setView("setup");
    }

    boot();
  </script>
</body>
</html>
