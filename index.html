<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Party Tracker</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; margin: 16px; line-height: 1.25; }
    .row { display: flex; gap: 16px; flex-wrap: wrap; }
    .card { border: 1px solid #ddd; border-radius: 10px; padding: 12px; min-width: 280px; flex: 1; }
    h1 { font-size: 18px; margin: 0 0 10px; }
    h2 { font-size: 14px; margin: 12px 0 8px; }
    .muted { color: #666; font-size: 12px; }
    label { display: block; font-size: 12px; margin: 8px 0 4px; color: #333; }
    input[type="number"], select, textarea { width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 8px; }
    textarea { min-height: 100px; }
    button { padding: 8px 10px; border: 1px solid #bbb; border-radius: 8px; background: #f7f7f7; cursor: pointer; }
    button:hover { background: #f0f0f0; }
    .pill { display: inline-block; padding: 2px 8px; border: 1px solid #ddd; border-radius: 999px; font-size: 12px; margin-right: 6px; }
    .grid { display: grid; gap: 8px; }
    .grid2 { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .list { display: grid; gap: 8px; }
    .item { border: 1px solid #eee; border-radius: 10px; padding: 8px; }
    .item b { display: inline-block; margin-right: 6px; }
    .checkboxes { display: flex; flex-wrap: wrap; gap: 8px; }
    .slot { display: inline-flex; align-items: center; gap: 6px; padding: 6px 8px; border: 1px solid #eee; border-radius: 999px; font-size: 12px; }
    .kpi { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .kpi > div { padding: 6px 10px; border: 1px solid #eee; border-radius: 10px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New"; }
  </style>
</head>
<body>
  <h1>Party Session Tracker</h1>
  <div class="muted">Character sheet data is prefilled; per-session state saves automatically per character in this browser.</div>

  <div class="row" style="margin-top:12px;">
    <div class="card" style="flex:2;">
      <h2>Pick Character</h2>
      <div class="grid2">
        <div>
          <label>Character</label>
          <select id="pcSelect"></select>
        </div>
        <div>
          <label>Quick Actions</label>
          <div class="kpi">
            <button id="btnFullHeal" title="Sets current HP to max">Full Heal</button>
            <button id="btnShortRest" title="Resets short-rest resources + (optional) spell slots if you want that rule">Short Rest</button>
            <button id="btnLongRest" title="Resets long-rest resources + spell slots + sets HP to max">Long Rest</button>
          </div>
        </div>
      </div>

      <div style="margin-top:10px;" class="kpi">
        <div><b id="pcName">—</b> <span class="muted" id="pcMeta"></span></div>
        <div>AC: <b id="pcAC">—</b></div>
        <div>Speed: <b id="pcSpeed">—</b> ft</div>
        <div>Prof: <b id="pcProf">—</b></div>
      </div>

      <div class="grid2" style="margin-top:10px;">
        <div class="card" style="border-color:#eee;">
          <h2>HP</h2>
          <div class="grid2">
            <div>
              <label>Current HP</label>
              <input id="hpCurrent" type="number" min="0" />
            </div>
            <div>
              <label>Max HP</label>
              <input id="hpMax" type="number" min="1" />
            </div>
          </div>
          <div class="muted" style="margin-top:8px;">Current HP auto-saves.</div>
        </div>

        <div class="card" style="border-color:#eee;">
          <h2>Primary Info</h2>
          <div id="primaryPills"></div>
          <div class="muted" style="margin-top:8px;" id="aboutRumorHint">ABOUT/RUMOR are in the sheet data (not shown to players unless you want).</div>
        </div>
      </div>

      <div id="magicBlock" class="card" style="margin-top:10px; display:none;">
        <h2>Magic</h2>
        <div id="magicSummary" class="muted"></div>

        <div style="margin-top:10px;">
          <h2>Spell Slots</h2>
          <div id="spellSlotsUI" class="checkboxes"></div>
          <div class="muted" style="margin-top:6px;">
            Slots follow standard 5e for Level 2: Cleric = 3×1st; Paladin = 2×1st; Bard = 3×1st; Ranger = 2×1st.
          </div>
        </div>

        <div id="cantripsBlock" style="margin-top:12px; display:none;">
          <h2>Cantrips</h2>
          <div id="cantripsList" class="list"></div>
        </div>

        <div style="margin-top:12px;">
          <h2 id="spellsChooserTitle">Spells</h2>
          <div class="muted" id="spellsChooserHint"></div>
          <div id="spellsChooser" class="list" style="margin-top:8px;"></div>
        </div>
      </div>

      <div class="row" style="margin-top:10px;">
        <div class="card">
          <h2>Attacks</h2>
          <div id="attacksList" class="list"></div>
        </div>
        <div class="card">
          <h2>Features & Resources</h2>
          <div id="featuresList" class="list"></div>
        </div>
      </div>
    </div>

    <div class="card">
      <h2>Inventory</h2>
      <textarea id="inventoryText" placeholder="Add items as you get them..."></textarea>

      <h2 style="margin-top:12px;">Notes</h2>
      <textarea id="notesText" placeholder="Session notes..."></textarea>

      <div class="muted" style="margin-top:10px;">
        Everything here saves automatically per character in this browser.
      </div>
    </div>
  </div>

<script>
/**
 * OPTIMIZED CHARACTER SHEET FORMAT
 * - Avoids hardcoding “spell attack +5 / DC 13” in multiple places.
 * - Fixes the cleric slots issue: L2 cleric has 3x 1st-level slots, no 2nd-level.
 * - Separates "sheet data" (static) from "session state" (saved in localStorage).
 */

const PARTY = {
  version: "1.1",
  campaign: "Crystal Faire / Azurite Pointe",
  characters: [
    // --- NON-CASTERS / NO SPELLS ---
    {
      id: "seris_dawnblade",
      name: "Seris Dawnblade",
      class: "Fighter",
      race: "Human",
      level: 2,
      ac: 16,
      speedFt: 30,
      profBonus: 2,
      hp: { max: 20 },
      attacks: [
        { name: "Longsword", toHit: 5, damage: "1d8+5", notes: "Melee" }
      ],
      features: [
        { name: "Second Wind", uses: 1, recharge: "short_rest", effect: "Regain 1d10+2 HP" },
        { name: "Action Surge", uses: 1, recharge: "short_rest", effect: "On your turn, take one extra action" },
        { name: "Fighting Style: Dueling", effect: "+2 damage with one-handed melee weapon (no off-hand weapon)" }
      ],
      about: "A disciplined sword-for-hire escorting a small merchant group to and from the Crystal Faire.",
      rumor: "You once failed to hold a line. A village burned because you were ordered to retreat."
    },
    {
      id: "sable_thornscar",
      name: "Sable Thornscar",
      class: "Fighter",
      race: "Tiefling",
      level: 2,
      ac: 16,
      speedFt: 30,
      profBonus: 2,
      hp: { max: 21 },
      attacks: [
        { name: "Greatsword", toHit: 5, damage: "2d6+3", notes: "Melee" },
        { name: "Handaxe", toHit: 5, damage: "1d6+3", notes: "Thrown 20/60" }
      ],
      features: [
        { name: "Second Wind", uses: 1, recharge: "short_rest", effect: "Regain 1d10+2 HP" },
        { name: "Action Surge", uses: 1, recharge: "short_rest", effect: "On your turn, take one extra action" },
        { name: "Fighting Style: Great Weapon Fighting", effect: "Reroll 1s and 2s on damage dice for 2H weapons" }
      ],
      about: "A sellsword hired for festival security.",
      rumor: "You once walked away from a contract that felt wrong, even though the pay was good."
    },
    {
      id: "korrin_ashfang",
      name: "Korrin Ashfang",
      class: "Rogue",
      race: "Half-Orc",
      level: 2,
      ac: 14,
      speedFt: 30,
      profBonus: 2,
      hp: { max: 18 },
      attacks: [
        { name: "Shortsword", toHit: 5, damage: "1d6+3", notes: "Melee" },
        { name: "Shortbow", toHit: 5, damage: "1d6+3", notes: "Ranged 80/320" }
      ],
      features: [
        { name: "Sneak Attack", effect: "+1d6 damage 1/turn if you have advantage OR an ally is adjacent to target" },
        { name: "Cunning Action", effect: "Bonus action: Dash, Disengage, or Hide" }
      ],
      about: "Korrin came to the Crystal Faire chasing a rumor that someone she lost long ago may be here.",
      rumor: "You recognize Ka’el Stormbrew as a soldier tied to a painful memory."
    },
    {
      id: "azrael_cinderborn",
      name: "Azrael Cinderborn",
      class: "Barbarian",
      race: "Tiefling",
      level: 2,
      ac: 15,
      speedFt: 30,
      profBonus: 2,
      hp: { max: 25 },
      attacks: [
        { name: "Spear", toHit: 6, damage: "1d8+4", notes: "Melee / Thrown 20/60" }
      ],
      features: [
        { name: "Rage", uses: 2, recharge: "long_rest", effect: "Bonus action (1 min): +2 STR damage, resist B/P/S, adv STR checks+saves" },
        { name: "Reckless Attack", effect: "First attack: gain advantage on STR melee; enemies have advantage to hit you until your next turn" },
        { name: "Danger Sense", effect: "Advantage on DEX saves vs effects you can see" }
      ],
      about: "A fierce warrior who lives on instinct and momentum.",
      rumor: "You once took a brutal job that left scars you don’t like to talk about."
    },

    // --- CASTERS / SPELLS ---
    // IMPORTANT FIX: Cleric L2 has only 1st-level slots (3). No 2nd-level slots yet.
    // We'll store spell data in one consistent format:
    // magic: { type: "prepared"|"known", ability: "wis/cha/int", slots: {1:n,2:n...}, choose: n, options:[...] , cantrips:[...] }

    {
      id: "haldor_brightshield",
      name: "Haldor Brightshield",
      class: "Cleric (Life)",
      race: "Dwarf",
      level: 2,
      ac: 18,
      speedFt: 25,
      profBonus: 2,
      hp: { max: 18 },
      attacks: [
        { name: "Warhammer", toHit: 4, damage: "1d8+2", notes: "Melee" }
      ],
      features: [
        { name: "Disciple of Life", effect: "Healing spells restore extra HP (2 + spell level)" },
        { name: "Channel Divinity", uses: 1, recharge: "short_rest", effect: "Choose: Turn Undead OR Preserve Life (heal split 10 HP within 30 ft)" }
      ],
      magic: {
        type: "prepared",
        ability: "wis",
        // FIXED:
        slots: { 1: 3 },
        choose: 4,
        cantrips: [
          { name: "Sacred Flame", cast: "Action", range: "60 ft", effect: "DEX save or take 1d8 radiant" },
          { name: "Guidance", cast: "Action", range: "Touch", effect: "+1d4 to one ability check (Conc 1 min)" },
          { name: "Spare the Dying", cast: "Action", range: "Touch", effect: "Creature at 0 HP becomes stable" }
        ],
        options: [
          { name: "Bless", cast: "Action", range: "30 ft", effect: "Up to 3 allies add +1d4 to attacks & saves (Conc)" },
          { name: "Cure Wounds", cast: "Action", range: "Touch", effect: "Heal 1d8 + WIS" },
          { name: "Protection from Evil and Good", cast: "Action", range: "Touch", effect: "Certain creatures have disadvantage; can’t be charmed/frightened/possessed (Conc 10 min)" },
          { name: "Guiding Bolt", cast: "Action", range: "120 ft", effect: "4d6 radiant; next attack vs target has advantage" },
          { name: "Healing Word", cast: "Bonus", range: "60 ft", effect: "Heal 1d4 + WIS at range" },
          { name: "Sanctuary", cast: "Bonus", range: "30 ft", effect: "Enemies must WIS save to attack or choose new target (1 min)" }
        ]
      },
      about: "A battle-hardened dwarf of quiet faith.",
      rumor: "You once healed someone who later committed an unforgivable act."
    },

    {
      id: "ashara_solkindle",
      name: "Ashara Solkindle",
      class: "Cleric (Life)",
      race: "Fire Genasi",
      level: 2,
      ac: 16,
      speedFt: 30,
      profBonus: 2,
      hp: { max: 18 },
      attacks: [
        { name: "Staff", toHit: 3, damage: "1d8+1", notes: "Melee" }
      ],
      features: [
        { name: "Disciple of Life", effect: "Healing spells restore extra HP (2 + spell level)" },
        { name: "Channel Divinity", uses: 1, recharge: "short_rest", effect: "Choose: Turn Undead OR Preserve Life (heal split 10 HP within 30 ft)" }
      ],
      magic: {
        type: "prepared",
        ability: "wis",
        // FIXED:
        slots: { 1: 3 },
        choose: 4,
        cantrips: [
          { name: "Sacred Flame", cast: "Action", range: "60 ft", effect: "DEX save or take 1d8 radiant" },
          { name: "Guidance", cast: "Action", range: "Touch", effect: "+1d4 to one ability check (Conc 1 min)" },
          { name: "Spare the Dying", cast: "Action", range: "Touch", effect: "Creature at 0 HP becomes stable" }
        ],
        options: [
          { name: "Bless", cast: "Action", range: "30 ft", effect: "Up to 3 allies add +1d4 to attacks & saves (Conc)" },
          { name: "Cure Wounds", cast: "Action", range: "Touch", effect: "Heal 1d8 + WIS" },
          { name: "Protection from Evil and Good", cast: "Action", range: "Touch", effect: "Certain creatures have disadvantage; can’t be charmed/frightened/possessed (Conc 10 min)" },
          { name: "Guiding Bolt", cast: "Action", range: "120 ft", effect: "4d6 radiant; next attack vs target has advantage" },
          { name: "Healing Word", cast: "Bonus", range: "60 ft", effect: "Heal 1d4 + WIS at range" },
          { name: "Sanctuary", cast: "Bonus", range: "30 ft", effect: "Enemies must WIS save to attack or choose new target (1 min)" }
        ]
      },
      about: "A hooded healer whose prayers feel like warmth returning to cold hands.",
      rumor: "Your fate is tied to a powerful wizard turned evil necromancer."
    },

    {
      id: "edrin_valebright",
      name: "Edrin Valebright",
      class: "Paladin",
      race: "Human",
      level: 2,
      ac: 19,
      speedFt: 30,
      profBonus: 2,
      hp: { max: 20 },
      attacks: [
        { name: "Longsword", toHit: 5, damage: "1d8+3", notes: "Melee" }
      ],
      features: [
        { name: "Lay on Hands", pool: 10, recharge: "long_rest", effect: "Action (touch). Heal from pool of 10 HP/day" },
        { name: "Divine Smite", effect: "On hit, spend spell slot: +2d8 radiant (+1d8 vs undead/fiends)" }
      ],
      magic: {
        type: "prepared",
        ability: "cha",
        slots: { 1: 2 },
        choose: 3,
        cantrips: [],
        options: [
          { name: "Bless", cast: "Action", range: "30 ft", effect: "Up to 3 allies add +1d4 to attacks & saves (Conc)" },
          { name: "Command", cast: "Action", range: "60 ft", effect: "1-word command; failed WIS save: target obeys next turn" },
          { name: "Cure Wounds", cast: "Action", range: "Touch", effect: "Heal 1d8 + CHA" },
          { name: "Protection from Evil and Good", cast: "Action", range: "Touch", effect: "Certain creatures have disadvantage; can’t be charmed/frightened/possessed (Conc 10 min)" },
          { name: "Shield of Faith", cast: "Bonus", range: "Self/Ally", effect: "+2 AC (Conc 1 min)" }
        ]
      },
      about: "A young paladin sworn to protect the innocent.",
      rumor: "You once disobeyed an order to leave civilians behind."
    },

    {
      id: "rurik_goldnote",
      name: "Rurik Goldnote",
      class: "Bard",
      race: "Dwarf",
      level: 2,
      ac: 14,
      speedFt: 25,
      profBonus: 2,
      hp: { max: 17 },
      attacks: [
        { name: "Rapier", toHit: 3, damage: "1d8+1", notes: "Melee" }
      ],
      features: [
        { name: "Bardic Inspiration", uses: 3, recharge: "long_rest", effect: "Bonus: give ally a d6 for attack/save/check" },
        { name: "Song of Rest", effect: "During short rest, allies heal +1d6 extra" }
      ],
      magic: {
        type: "known",
        ability: "cha",
        slots: { 1: 3 },
        choose: 2,
        cantrips: [],
        options: [
          { name: "Healing Word", cast: "Bonus", range: "60 ft", effect: "Heal 1d4 + CHA at range" },
          { name: "Dissonant Whispers", cast: "Action", range: "60 ft", effect: "3d6 psychic; target uses reaction to run away (WIS save)" },
          { name: "Faerie Fire", cast: "Action", range: "60 ft", effect: "Outline creatures; attacks have advantage; they can’t be invisible (Conc 1 min, DEX save)" },
          { name: "Sleep", cast: "Action", range: "90 ft", effect: "Put creatures to sleep in an area; best vs weak enemies" },
          { name: "Tasha’s Hideous Laughter", cast: "Action", range: "30 ft", effect: "Target prone/incapacitated until save (Conc 1 min, WIS save)" },
          { name: "Detect Magic", cast: "Action", range: "Self", effect: "Sense magic within 30 ft (Conc 10 min)" }
        ]
      },
      about: "A traveling bard picked up by Ka’el’s unit.",
      rumor: "You overheard soldiers joking about how much digging they do — it didn’t feel like a joke."
    },

    {
      id: "lark_thistledown",
      name: "Lark Thistledown",
      class: "Bard",
      race: "Halfling",
      level: 2,
      ac: 14,
      speedFt: 25,
      profBonus: 2,
      hp: { max: 15 },
      attacks: [
        { name: "Rapier", toHit: 5, damage: "1d8+3", notes: "Melee" }
      ],
      features: [
        { name: "Bardic Inspiration", uses: 3, recharge: "long_rest", effect: "Bonus: give ally a d6 for attack/save/check" },
        { name: "Song of Rest", effect: "During short rest, allies heal +1d6 extra" }
      ],
      magic: {
        type: "known",
        ability: "cha",
        slots: { 1: 3 },
        choose: 2,
        cantrips: [],
        options: [
          { name: "Healing Word", cast: "Bonus", range: "60 ft", effect: "Heal 1d4 + CHA at range" },
          { name: "Dissonant Whispers", cast: "Action", range: "60 ft", effect: "3d6 psychic; target uses reaction to run away (WIS save)" },
          { name: "Faerie Fire", cast: "Action", range: "60 ft", effect: "Outline creatures; attacks have advantage; they can’t be invisible (Conc 1 min, DEX save)" },
          { name: "Sleep", cast: "Action", range: "90 ft", effect: "Put creatures to sleep in an area; best vs weak enemies" },
          { name: "Tasha’s Hideous Laughter", cast: "Action", range: "30 ft", effect: "Target prone/incapacitated until save (Conc 1 min, WIS save)" },
          { name: "Detect Magic", cast: "Action", range: "Self", effect: "Sense magic within 30 ft (Conc 10 min)" }
        ]
      },
      about: "A runaway noble bard.",
      rumor: "You hid off the road and watched wagons already full of cargo heading into the city."
    },

    {
      id: "liora_windstep",
      name: "Liora Windstep",
      class: "Ranger",
      race: "Wood Elf",
      level: 2,
      ac: 15,
      speedFt: 30,
      profBonus: 2,
      hp: { max: 19 },
      attacks: [
        { name: "Longbow", toHit: 5, damage: "1d8+3", notes: "Ranged 150/600" },
        { name: "Shortsword", toHit: 5, damage: "1d6+3", notes: "Melee" }
      ],
      features: [
        { name: "Favored Enemy", effect: "Advantage tracking / recalling info about undead (per your sheet flavor)" },
        { name: "Natural Explorer", effect: "Coastal/Forest benefits (per your sheet flavor)" }
      ],
      magic: {
        type: "known",
        ability: "wis",
        slots: { 1: 2 },
        choose: 2,
        cantrips: [],
        options: [
          { name: "Hunter’s Mark", cast: "Bonus", range: "90 ft", effect: "Mark target; +1d6 each hit; advantage tracking (Conc 1 hr)" },
          { name: "Cure Wounds", cast: "Action", range: "Touch", effect: "Heal 1d8 + WIS" },
          { name: "Goodberry", cast: "Action", range: "—", effect: "Create 10 berries: each heals 1 HP and counts as a day of food" },
          { name: "Fog Cloud", cast: "Action", range: "120 ft", effect: "Big cloud blocks vision (Conc 1 hr)" },
          { name: "Detect Magic", cast: "Action", range: "Self", effect: "Sense magic within 30 ft (Conc 10 min)" },
          { name: "Snare", cast: "1 minute", range: "25 ft", effect: "Hidden trap; first creature triggers save or restrained & lifted" }
        ]
      },
      about: "A quiet scout watching the horizon as much as people.",
      rumor: "You’ve been following signs of strange movement in the wilds leading toward the Obelisk."
    }
  ]
};

// ---------- STORAGE ----------
function stateKey(pcId) { return `pc_state_${pcId}`; }

function defaultStateFor(pc) {
  const state = {
    currentHp: pc.hp?.max ?? 10,
    hpMax: pc.hp?.max ?? 10,
    inventoryText: "",
    notesText: "",
    resources: {},          // keyed by feature name
    spellSlotsUsed: {},     // e.g. { "1": [false,false,false] }
    chosenSpells: []        // list of spell names (prepared/known selection)
  };

  // initialize resources checkboxes/counts
  (pc.features || []).forEach(f => {
    if (typeof f.uses === "number") state.resources[f.name] = { usedCount: 0 };
    if (typeof f.pool === "number") state.resources[f.name] = { poolRemaining: f.pool };
  });

  // initialize slot checkboxes arrays
  if (pc.magic?.slots) {
    Object.entries(pc.magic.slots).forEach(([lvl, n]) => {
      state.spellSlotsUsed[lvl] = Array.from({ length: n }, () => false);
    });
  }

  return state;
}

function loadState(pc) {
  const raw = localStorage.getItem(stateKey(pc.id));
  if (!raw) return defaultStateFor(pc);
  try {
    const parsed = JSON.parse(raw);
    // merge with defaults to avoid missing keys after schema changes
    const merged = defaultStateFor(pc);

    // keep any persisted content
    if (typeof parsed.currentHp === "number") merged.currentHp = parsed.currentHp;
    if (typeof parsed.hpMax === "number") merged.hpMax = parsed.hpMax;
    if (typeof parsed.inventoryText === "string") merged.inventoryText = parsed.inventoryText;
    if (typeof parsed.notesText === "string") merged.notesText = parsed.notesText;
    if (parsed.resources && typeof parsed.resources === "object") merged.resources = { ...merged.resources, ...parsed.resources };
    if (parsed.spellSlotsUsed && typeof parsed.spellSlotsUsed === "object") merged.spellSlotsUsed = { ...merged.spellSlotsUsed, ...parsed.spellSlotsUsed };
    if (Array.isArray(parsed.chosenSpells)) merged.chosenSpells = parsed.chosenSpells.slice();
    return merged;
  } catch {
    return defaultStateFor(pc);
  }
}

function saveState(pcId, state) {
  localStorage.setItem(stateKey(pcId), JSON.stringify(state));
}

// ---------- RENDER ----------
const el = (id) => document.getElementById(id);

let currentPc = null;
let currentState = null;

function setText(id, txt) { el(id).textContent = txt; }
function clear(node) { while (node.firstChild) node.removeChild(node.firstChild); }

function computeSpellNumbers(pc) {
  // Only show if spellcasting exists
  if (!pc.magic) return null;
  const ability = pc.magic.ability; // "wis" / "cha" / ...
  // We only have simplified “mod” elsewhere; since you’re prefilled sheets, we’ll compute DC/Attack
  // using a common 5e formula: DC = 8 + prof + abilityMod; Attack = prof + abilityMod
  // If you want literal sheet values, we can store override fields later.
  const abilityModMap = pc.abilityMods || null;
  // If no mods provided, we can’t compute reliably—so we won’t pretend.
  if (!abilityModMap || typeof abilityModMap[ability] !== "number") {
    return { dc: null, atk: null };
  }
  const mod = abilityModMap[ability];
  return { dc: 8 + pc.profBonus + mod, atk: pc.profBonus + mod };
}

function renderPc(pc) {
  currentPc = pc;
  currentState = loadState(pc);

  setText("pcName", pc.name);
  setText("pcMeta", `${pc.race} • ${pc.class} • L${pc.level}`);
  setText("pcAC", pc.ac ?? "—");
  setText("pcSpeed", pc.speedFt ?? "—");
  setText("pcProf", `+${pc.profBonus ?? 0}`);

  // primary pills
  const pills = el("primaryPills");
  clear(pills);
  const pillList = [
    `HP ${currentState.currentHp}/${currentState.hpMax}`,
    `AC ${pc.ac ?? "—"}`,
    `Speed ${pc.speedFt ?? "—"}`
  ];
  pillList.forEach(t => {
    const span = document.createElement("span");
    span.className = "pill";
    span.textContent = t;
    pills.appendChild(span);
  });

  // HP inputs
  el("hpCurrent").value = currentState.currentHp;
  el("hpMax").value = currentState.hpMax;

  // inventory/notes
  el("inventoryText").value = currentState.inventoryText;
  el("notesText").value = currentState.notesText;

  // attacks
  const atkList = el("attacksList");
  clear(atkList);
  (pc.attacks || []).forEach(a => {
    const div = document.createElement("div");
    div.className = "item";
    div.innerHTML = `<div><b>${a.name}</b> <span class="muted">${a.notes ?? ""}</span></div>
      <div class="mono">To Hit: +${a.toHit} • Damage: ${a.damage}</div>`;
    atkList.appendChild(div);
  });

  // features/resources
  const featList = el("featuresList");
  clear(featList);
  (pc.features || []).forEach(f => {
    const div = document.createElement("div");
    div.className = "item";

    const top = document.createElement("div");
    top.innerHTML = `<b>${f.name}</b> <span class="muted">${f.recharge ? `(${f.recharge.replace("_"," ")})` : ""}</span>`;
    div.appendChild(top);

    const eff = document.createElement("div");
    eff.className = "muted";
    eff.textContent = f.effect ?? "";
    div.appendChild(eff);

    // resource controls if uses/pool exist
    const controls = document.createElement("div");
    controls.style.marginTop = "8px";

    if (typeof f.uses === "number") {
      const st = currentState.resources[f.name] || { usedCount: 0 };
      currentState.resources[f.name] = st;

      const used = document.createElement("input");
      used.type = "number";
      used.min = 0;
      used.max = f.uses;
      used.value = st.usedCount ?? 0;

      const lbl = document.createElement("span");
      lbl.className = "muted";
      lbl.textContent = `Used (max ${f.uses})`;

      used.addEventListener("input", () => {
        const v = Math.max(0, Math.min(f.uses, Number(used.value || 0)));
        st.usedCount = v;
        saveState(pc.id, currentState);
      });

      const wrap = document.createElement("div");
      wrap.className = "grid2";
      wrap.appendChild(used);
      wrap.appendChild(lbl);
      controls.appendChild(wrap);
      div.appendChild(controls);
    }

    if (typeof f.pool === "number") {
      const st = currentState.resources[f.name] || { poolRemaining: f.pool };
      currentState.resources[f.name] = st;

      const pool = document.createElement("input");
      pool.type = "number";
      pool.min = 0;
      pool.max = f.pool;
      pool.value = st.poolRemaining ?? f.pool;

      const lbl = document.createElement("span");
      lbl.className = "muted";
      lbl.textContent = `Remaining (max ${f.pool})`;

      pool.addEventListener("input", () => {
        const v = Math.max(0, Math.min(f.pool, Number(pool.value || 0)));
        st.poolRemaining = v;
        saveState(pc.id, currentState);
      });

      const wrap = document.createElement("div");
      wrap.className = "grid2";
      wrap.appendChild(pool);
      wrap.appendChild(lbl);
      controls.appendChild(wrap);
      div.appendChild(controls);
    }

    featList.appendChild(div);
  });

  // magic
  const magicBlock = el("magicBlock");
  const hasMagic = !!pc.magic;
  magicBlock.style.display = hasMagic ? "block" : "none";

  if (hasMagic) {
    // summary
    const m = pc.magic;
    const knownOrPrepared = m.type === "prepared" ? "Prepared" : "Known";
    setText("magicSummary", `${knownOrPrepared} caster • Spell ability: ${m.ability.toUpperCase()}`);

    // spell slots UI
    const slotsUI = el("spellSlotsUI");
    clear(slotsUI);

    Object.entries(m.slots || {}).forEach(([lvl, n]) => {
      const arr = currentState.spellSlotsUsed[lvl] || Array.from({ length: n }, () => false);
      // normalize length
      currentState.spellSlotsUsed[lvl] = arr.slice(0, n);
      while (currentState.spellSlotsUsed[lvl].length < n) currentState.spellSlotsUsed[lvl].push(false);

      for (let i = 0; i < n; i++) {
        const wrap = document.createElement("label");
        wrap.className = "slot";
        const cb = document.createElement("input");
        cb.type = "checkbox";
        cb.checked = !!currentState.spellSlotsUsed[lvl][i];

        cb.addEventListener("change", () => {
          currentState.spellSlotsUsed[lvl][i] = cb.checked;
          saveState(pc.id, currentState);
        });

        const txt = document.createElement("span");
        txt.textContent = `L${lvl} Slot ${i + 1}`;

        wrap.appendChild(cb);
        wrap.appendChild(txt);
        slotsUI.appendChild(wrap);
      }
    });

    // cantrips
    const cantripsBlock = el("cantripsBlock");
    const cantripsList = el("cantripsList");
    clear(cantripsList);

    if (Array.isArray(m.cantrips) && m.cantrips.length > 0) {
      cantripsBlock.style.display = "block";
      m.cantrips.forEach(c => {
        const div = document.createElement("div");
        div.className = "item";
        div.innerHTML = `<div><b>${c.name}</b> <span class="muted">${c.cast ?? ""} • ${c.range ?? ""}</span></div>
                         <div class="muted">${c.effect ?? ""}</div>`;
        cantripsList.appendChild(div);
      });
    } else {
      cantripsBlock.style.display = "none";
    }

    // spells chooser
    const chooser = el("spellsChooser");
    clear(chooser);

    const chooseN = m.choose ?? 0;
    const title = (m.type === "prepared")
      ? `Prepared Spells — choose ${chooseN}`
      : `Spells Known — choose ${chooseN}`;
    setText("spellsChooserTitle", title);
    setText("spellsChooserHint", "Tap to select. Your choices auto-save.");

    // normalize chosen spells
    if (!Array.isArray(currentState.chosenSpells)) currentState.chosenSpells = [];
    // If old state contains spells not in options, keep them but they won’t render (safe).
    const options = m.options || [];

    options.forEach(sp => {
      const div = document.createElement("div");
      div.className = "item";

      const isChecked = currentState.chosenSpells.includes(sp.name);

      const row = document.createElement("div");
      row.className = "grid2";

      const left = document.createElement("div");
      left.innerHTML = `<b>${sp.name}</b><div class="muted">${sp.cast ?? ""} • ${sp.range ?? ""}</div>`;

      const right = document.createElement("div");
      right.style.textAlign = "right";

      const cb = document.createElement("input");
      cb.type = "checkbox";
      cb.checked = isChecked;

      cb.addEventListener("change", () => {
        const selected = new Set(currentState.chosenSpells);
        if (cb.checked) selected.add(sp.name);
        else selected.delete(sp.name);

        // enforce choose limit
        const arr = Array.from(selected);
        if (chooseN > 0 && arr.length > chooseN) {
          cb.checked = false;
          return;
        }

        currentState.chosenSpells = arr;
        saveState(pc.id, currentState);
      });

      right.appendChild(cb);

      row.appendChild(left);
      row.appendChild(right);
      div.appendChild(row);

      const eff = document.createElement("div");
      eff.className = "muted";
      eff.textContent = sp.effect ?? "";
      div.appendChild(eff);

      chooser.appendChild(div);
    });

    // persist state after render normalization
    saveState(pc.id, currentState);
  }

  // hook listeners (HP/inventory/notes)
  el("hpCurrent").oninput = () => {
    currentState.currentHp = Number(el("hpCurrent").value || 0);
    saveState(pc.id, currentState);
    renderPrimaryHpPill();
  };

  el("hpMax").oninput = () => {
    currentState.hpMax = Math.max(1, Number(el("hpMax").value || 1));
    saveState(pc.id, currentState);
    renderPrimaryHpPill();
  };

  el("inventoryText").oninput = () => {
    currentState.inventoryText = el("inventoryText").value;
    saveState(pc.id, currentState);
  };

  el("notesText").oninput = () => {
    currentState.notesText = el("notesText").value;
    saveState(pc.id, currentState);
  };
}

function renderPrimaryHpPill() {
  // update the first pill only
  const pills = el("primaryPills");
  if (!pills.firstChild) return;
  pills.firstChild.textContent = `HP ${currentState.currentHp}/${currentState.hpMax}`;
}

// ---------- REST BUTTONS ----------
function doFullHeal() {
  if (!currentPc) return;
  currentState.currentHp = currentState.hpMax;
  el("hpCurrent").value = currentState.currentHp;
  saveState(currentPc.id, currentState);
  renderPrimaryHpPill();
}

function doShortRest() {
  if (!currentPc) return;

  // reset resources with recharge short_rest
  (currentPc.features || []).forEach(f => {
    if (f.recharge === "short_rest" && typeof f.uses === "number") {
      const st = currentState.resources[f.name];
      if (st) st.usedCount = 0;
    }
    if (f.recharge === "short_rest" && typeof f.pool === "number") {
      const st = currentState.resources[f.name];
      if (st) st.poolRemaining = f.pool;
    }
  });

  // NOTE: In standard 5e, spell slots do NOT come back on short rest (unless features say otherwise).
  // Keeping slots as-is.

  saveState(currentPc.id, currentState);
  renderPc(currentPc);
}

function doLongRest() {
  if (!currentPc) return;

  // full HP
  currentState.currentHp = currentState.hpMax;

  // reset all resources that are "long_rest" or "short_rest" or "day"
  (currentPc.features || []).forEach(f => {
    const r = f.recharge;
    if ((r === "long_rest" || r === "day" || r === "short_rest") && typeof f.uses === "number") {
      const st = currentState.resources[f.name];
      if (st) st.usedCount = 0;
    }
    if ((r === "long_rest" || r === "day" || r === "short_rest") && typeof f.pool === "number") {
      const st = currentState.resources[f.name];
      if (st) st.poolRemaining = f.pool;
    }
  });

  // reset spell slots
  if (currentPc.magic?.slots) {
    Object.entries(currentPc.magic.slots).forEach(([lvl, n]) => {
      currentState.spellSlotsUsed[lvl] = Array.from({ length: n }, () => false);
    });
  }

  saveState(currentPc.id, currentState);
  renderPc(currentPc);
}

// ---------- INIT ----------
function init() {
  const sel = el("pcSelect");
  clear(sel);

  PARTY.characters.forEach(pc => {
    const opt = document.createElement("option");
    opt.value = pc.id;
    opt.textContent = pc.name;
    sel.appendChild(opt);
  });

  sel.addEventListener("change", () => {
    const pc = PARTY.characters.find(c => c.id === sel.value);
    if (pc) renderPc(pc);
  });

  el("btnFullHeal").addEventListener("click", doFullHeal);
  el("btnShortRest").addEventListener("click", doShortRest);
  el("btnLongRest").addEventListener("click", doLongRest);

  // Default to first character
  const first = PARTY.characters[0];
  sel.value = first.id;
  renderPc(first);
}

init();
</script>
</body>
</html>